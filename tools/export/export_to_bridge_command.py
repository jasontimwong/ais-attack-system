#!/usr/bin/env python3
"""
Bridge Command Export Tool for AIS Attack Generation System

This tool exports AIS attack scenarios to Bridge Command simulator format.
Bridge Command is a professional ship bridge simulator used for maritime training.
"""

import os
import sys
import json
import argparse
import pandas as pd
import numpy as np
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET
import csv

class BridgeCommandExporter:
    """
    Export AIS attack scenarios to Bridge Command format
    """
    
    def __init__(self):
        self.scenario_template = {
            'version': '5.0',
            'start_time': 12.0,  # Hours since midnight
            'start_date': 1,     # Day of year
            'start_year': 2024,
            'weather': {
                'visibility': 10.0,  # Nautical miles
                'rain': 0.0,
                'wind_speed': 5.0,   # Knots
                'wind_direction': 270.0  # Degrees
            },
            'tide': 0.0,  # Meters
            'variation': 0.0  # Magnetic variation
        }
    
    def export_scenario(self, 
                       attack_data: Dict, 
                       output_dir: str,
                       scenario_name: str = "ais_attack") -> str:
        """
        Export complete attack scenario to Bridge Command format
        
        Args:
            attack_data: Attack scenario data
            output_dir: Output directory path
            scenario_name: Scenario name
            
        Returns:
            Path to generated scenario directory
        """
        output_path = Path(output_dir) / scenario_name
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Extract trajectories
        baseline_trajectory = attack_data.get('baseline_trajectory', [])
        attack_trajectory = attack_data.get('attack_trajectory', [])
        
        # Create scenario XML
        scenario_xml_path = self._create_scenario_xml(
            attack_data, output_path, scenario_name
        )
        
        # Create vessel routes
        if baseline_trajectory:
            self._create_vessel_route(
                baseline_trajectory, 
                output_path / "baseline_route.csv",
                vessel_name="Target_Vessel"
            )
        
        if attack_trajectory:
            self._create_vessel_route(
                attack_trajectory,
                output_path / "attack_route.csv", 
                vessel_name="Ghost_Vessel"
            )
        
        # Create environment file
        self._create_environment_file(attack_data, output_path)
        
        # Create README
        self._create_readme(attack_data, output_path, scenario_name)
        
        print(f"✅ Bridge Command scenario exported to: {output_path}")
        return str(output_path)
    
    def _create_scenario_xml(self, 
                           attack_data: Dict, 
                           output_path: Path, 
                           scenario_name: str) -> str:
        """Create Bridge Command scenario XML file"""
        
        # Create root element
        root = ET.Element("Scenario")
        root.set("version", self.scenario_template['version'])
        
        # Basic scenario information
        info = ET.SubElement(root, "Information")
        ET.SubElement(info, "Name").text = scenario_name
        ET.SubElement(info, "Description").text = attack_data.get(
            'description', 'AIS Attack Scenario Generated by AIS Attack System'
        )
        
        # Time and date settings
        time_elem = ET.SubElement(root, "Time")
        ET.SubElement(time_elem, "StartTime").text = str(self.scenario_template['start_time'])
        ET.SubElement(time_elem, "StartDay").text = str(self.scenario_template['start_date'])
        ET.SubElement(time_elem, "StartYear").text = str(self.scenario_template['start_year'])
        
        # Weather conditions
        weather = ET.SubElement(root, "Weather")
        weather_config = self.scenario_template['weather']
        ET.SubElement(weather, "Visibility").text = str(weather_config['visibility'])
        ET.SubElement(weather, "Rain").text = str(weather_config['rain'])
        ET.SubElement(weather, "WindSpeed").text = str(weather_config['wind_speed'])
        ET.SubElement(weather, "WindDirection").text = str(weather_config['wind_direction'])
        
        # Tide
        ET.SubElement(root, "Tide").text = str(self.scenario_template['tide'])
        
        # Variation
        ET.SubElement(root, "Variation").text = str(self.scenario_template['variation'])
        
        # Vessels
        vessels = ET.SubElement(root, "Vessels")
        
        # Add target vessel
        if 'target_mmsi' in attack_data:
            target_vessel = ET.SubElement(vessels, "Vessel")
            target_vessel.set("type", "OwnShip")
            ET.SubElement(target_vessel, "Name").text = "Target_Vessel"
            ET.SubElement(target_vessel, "MMSI").text = attack_data['target_mmsi']
            ET.SubElement(target_vessel, "Model").text = "Cargo"  # Default model
            
            # Initial position from baseline trajectory
            baseline = attack_data.get('baseline_trajectory', [])
            if baseline:
                first_point = baseline[0]
                ET.SubElement(target_vessel, "InitialLat").text = str(first_point.get('lat', 0))
                ET.SubElement(target_vessel, "InitialLon").text = str(first_point.get('lon', 0))
                ET.SubElement(target_vessel, "InitialSpeed").text = str(first_point.get('speed', 10))
                ET.SubElement(target_vessel, "InitialCourse").text = str(first_point.get('course', 0))
        
        # Add ghost vessel
        if 'ghost_mmsi' in attack_data:
            ghost_vessel = ET.SubElement(vessels, "Vessel")
            ghost_vessel.set("type", "OtherShip")
            ET.SubElement(ghost_vessel, "Name").text = "Ghost_Vessel"
            ET.SubElement(ghost_vessel, "MMSI").text = attack_data['ghost_mmsi']
            ET.SubElement(ghost_vessel, "Model").text = "Cargo"  # Default model
            
            # Initial position from attack trajectory
            attack_traj = attack_data.get('attack_trajectory', [])
            if attack_traj:
                first_point = attack_traj[0]
                ET.SubElement(ghost_vessel, "InitialLat").text = str(first_point.get('lat', 0))
                ET.SubElement(ghost_vessel, "InitialLon").text = str(first_point.get('lon', 0))
                ET.SubElement(ghost_vessel, "InitialSpeed").text = str(first_point.get('speed', 10))
                ET.SubElement(ghost_vessel, "InitialCourse").text = str(first_point.get('course', 0))
        
        # Write XML file
        xml_path = output_path / "scenario.xml"
        tree = ET.ElementTree(root)
        ET.indent(tree, space="  ", level=0)
        tree.write(xml_path, encoding="utf-8", xml_declaration=True)
        
        return str(xml_path)
    
    def _create_vessel_route(self, 
                           trajectory: List[Dict], 
                           output_path: Path,
                           vessel_name: str) -> str:
        """Create vessel route CSV file for Bridge Command"""
        
        if not trajectory:
            return ""
        
        # Prepare route data
        route_data = []
        
        for i, point in enumerate(trajectory):
            # Calculate time offset from start
            if 'timestamp' in point:
                if i == 0:
                    time_offset = 0.0
                else:
                    # Calculate time difference from previous point
                    prev_time = pd.to_datetime(trajectory[i-1]['timestamp'])
                    curr_time = pd.to_datetime(point['timestamp'])
                    time_offset = (curr_time - prev_time).total_seconds()
            else:
                time_offset = i * 30.0  # Default 30-second intervals
            
            route_point = {
                'Time': time_offset,
                'Latitude': point.get('lat', 0.0),
                'Longitude': point.get('lon', 0.0),
                'Speed': point.get('speed', 10.0),
                'Course': point.get('course', 0.0),
                'Waypoint': f"WP_{i+1:03d}"
            }
            
            route_data.append(route_point)
        
        # Write CSV file
        with open(output_path, 'w', newline='') as csvfile:
            fieldnames = ['Time', 'Latitude', 'Longitude', 'Speed', 'Course', 'Waypoint']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            
            writer.writeheader()
            for row in route_data:
                writer.writerow(row)
        
        print(f"✅ Created route file: {output_path}")
        return str(output_path)
    
    def _create_environment_file(self, attack_data: Dict, output_path: Path) -> str:
        """Create environment configuration file"""
        
        env_config = {
            'scenario_info': {
                'name': attack_data.get('scenario_name', 'AIS Attack Scenario'),
                'description': attack_data.get('description', ''),
                'attack_type': attack_data.get('attack_type', 'unknown'),
                'generated_by': 'AIS Attack Generation System',
                'generated_at': datetime.now().isoformat()
            },
            'geographic_bounds': attack_data.get('geographic_bounds', {}),
            'weather_conditions': self.scenario_template['weather'],
            'attack_parameters': {
                'target_mmsi': attack_data.get('target_mmsi'),
                'ghost_mmsi': attack_data.get('ghost_mmsi'),
                'attack_stages': attack_data.get('attack_stages', []),
                'success_metrics': attack_data.get('metrics', {})
            }
        }
        
        env_path = output_path / "environment.json"
        with open(env_path, 'w') as f:
            json.dump(env_config, f, indent=2, default=str)
        
        return str(env_path)
    
    def _create_readme(self, attack_data: Dict, output_path: Path, scenario_name: str) -> str:
        """Create README file for the scenario"""
        
        readme_content = f"""# Bridge Command Scenario: {scenario_name}

## Overview

This scenario was generated by the AIS Attack Generation System and contains an AIS attack simulation suitable for Bridge Command simulator.

## Scenario Details

- **Attack Type**: {attack_data.get('attack_type', 'Unknown')}
- **Target MMSI**: {attack_data.get('target_mmsi', 'N/A')}
- **Ghost MMSI**: {attack_data.get('ghost_mmsi', 'N/A')}
- **Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Files Included

- `scenario.xml` - Main Bridge Command scenario file
- `baseline_route.csv` - Target vessel route (if available)
- `attack_route.csv` - Ghost vessel route (if available)
- `environment.json` - Environment and attack parameters
- `README.md` - This file

## Loading in Bridge Command

1. Copy this entire folder to your Bridge Command scenarios directory
2. Start Bridge Command simulator
3. Load the scenario using the scenario selection menu
4. The target vessel should follow the baseline route
5. The ghost vessel will execute the attack pattern

## Attack Stages

"""
        
        # Add attack stages information
        if 'attack_stages' in attack_data:
            for i, stage in enumerate(attack_data['attack_stages'], 1):
                readme_content += f"### Stage {i}: {stage.get('name', 'Unknown')}\n\n"
                readme_content += f"- Duration: {stage.get('duration', 0)} seconds\n"
                readme_content += f"- Behavior: {stage.get('behavior', 'Unknown')}\n"
                if 'description' in stage:
                    readme_content += f"- Description: {stage['description']}\n"
                readme_content += "\n"
        
        # Add metrics if available
        if 'metrics' in attack_data:
            readme_content += "## Success Metrics\n\n"
            metrics = attack_data['metrics']
            for key, value in metrics.items():
                readme_content += f"- **{key.replace('_', ' ').title()}**: {value}\n"
            readme_content += "\n"
        
        readme_content += """## Notes

- This scenario is generated for research and training purposes only
- Ensure proper safety protocols when using in training environments
- The attack patterns are based on theoretical models and may not reflect real-world attack behaviors exactly
- For questions about this scenario, refer to the AIS Attack Generation System documentation

## Bridge Command Compatibility

This scenario is designed for Bridge Command version 5.0 and later. Earlier versions may require manual adjustments to the scenario.xml file.

## Support

For technical support with the AIS Attack Generation System, please refer to:
- GitHub Repository: https://github.com/jasontimwong/ais-attack-system
- Documentation: docs/
- Issues: GitHub Issues tracker
"""
        
        readme_path = output_path / "README.md"
        with open(readme_path, 'w') as f:
            f.write(readme_content)
        
        return str(readme_path)
    
    def export_from_geojson(self, 
                           baseline_geojson: str,
                           attack_geojson: str = None,
                           output_dir: str = "bridge_command_output",
                           scenario_name: str = "ais_attack") -> str:
        """
        Export scenario from GeoJSON files
        
        Args:
            baseline_geojson: Path to baseline trajectory GeoJSON
            attack_geojson: Path to attack trajectory GeoJSON (optional)
            output_dir: Output directory
            scenario_name: Scenario name
            
        Returns:
            Path to generated scenario directory
        """
        # Load baseline trajectory
        baseline_trajectory = self._load_geojson_trajectory(baseline_geojson)
        
        # Load attack trajectory if provided
        attack_trajectory = []
        if attack_geojson and Path(attack_geojson).exists():
            attack_trajectory = self._load_geojson_trajectory(attack_geojson)
        
        # Create attack data structure
        attack_data = {
            'scenario_name': scenario_name,
            'baseline_trajectory': baseline_trajectory,
            'attack_trajectory': attack_trajectory,
            'target_mmsi': baseline_trajectory[0].get('mmsi', '123456789') if baseline_trajectory else '123456789',
            'ghost_mmsi': attack_trajectory[0].get('mmsi', '987654321') if attack_trajectory else '987654321',
            'attack_type': 'geojson_import',
            'description': f'Scenario imported from GeoJSON files: {Path(baseline_geojson).name}'
        }
        
        return self.export_scenario(attack_data, output_dir, scenario_name)
    
    def _load_geojson_trajectory(self, geojson_path: str) -> List[Dict]:
        """Load trajectory from GeoJSON file"""
        with open(geojson_path, 'r') as f:
            data = json.load(f)
        
        trajectory = []
        
        for feature in data.get('features', []):
            if feature['geometry']['type'] == 'Point':
                coords = feature['geometry']['coordinates']
                props = feature['properties']
                
                point = {
                    'lat': coords[1],
                    'lon': coords[0],
                    'timestamp': props.get('timestamp'),
                    'speed': props.get('speed', 10.0),
                    'course': props.get('course', 0.0),
                    'mmsi': props.get('mmsi')
                }
                
                trajectory.append(point)
        
        # Sort by timestamp if available
        if trajectory and 'timestamp' in trajectory[0]:
            trajectory.sort(key=lambda x: x['timestamp'] or '')
        
        return trajectory
    
    def create_batch_scenarios(self, 
                              input_dir: str, 
                              output_dir: str = "bridge_command_batch") -> List[str]:
        """
        Create Bridge Command scenarios from multiple attack scenario files
        
        Args:
            input_dir: Directory containing attack scenario files
            output_dir: Output directory for Bridge Command scenarios
            
        Returns:
            List of generated scenario directory paths
        """
        input_path = Path(input_dir)
        
        if not input_path.exists():
            raise ValueError(f"Input directory not found: {input_dir}")
        
        generated_scenarios = []
        
        # Find scenario files
        scenario_files = list(input_path.glob("**/attack_results.json")) + \
                        list(input_path.glob("**/scenario_data.json"))
        
        for scenario_file in scenario_files:
            try:
                with open(scenario_file, 'r') as f:
                    scenario_data = json.load(f)
                
                scenario_name = scenario_file.parent.name
                output_path = self.export_scenario(
                    scenario_data, output_dir, scenario_name
                )
                generated_scenarios.append(output_path)
                
            except Exception as e:
                print(f"❌ Failed to process {scenario_file}: {e}")
        
        return generated_scenarios

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Export AIS attack scenarios to Bridge Command format"
    )
    parser.add_argument("input", help="Input file or directory")
    parser.add_argument("--output", "-o", default="bridge_command_output",
                       help="Output directory")
    parser.add_argument("--scenario-name", "-n", default="ais_attack",
                       help="Scenario name")
    parser.add_argument("--attack-file", "-a", 
                       help="Attack trajectory file (for GeoJSON mode)")
    parser.add_argument("--batch", "-b", action="store_true",
                       help="Process multiple scenarios in directory")
    
    args = parser.parse_args()
    
    exporter = BridgeCommandExporter()
    
    try:
        input_path = Path(args.input)
        
        if not input_path.exists():
            print(f"❌ Error: Input path not found: {args.input}")
            sys.exit(1)
        
        if args.batch:
            # Batch processing mode
            scenarios = exporter.create_batch_scenarios(args.input, args.output)
            print(f"✅ Generated {len(scenarios)} Bridge Command scenarios:")
            for scenario in scenarios:
                print(f"  • {scenario}")
        
        elif input_path.suffix.lower() == '.geojson':
            # GeoJSON mode
            output_path = exporter.export_from_geojson(
                args.input, 
                args.attack_file,
                args.output,
                args.scenario_name
            )
            print(f"✅ Bridge Command scenario created: {output_path}")
        
        elif input_path.suffix.lower() == '.json':
            # JSON scenario file mode
            with open(input_path, 'r') as f:
                scenario_data = json.load(f)
            
            output_path = exporter.export_scenario(
                scenario_data,
                args.output, 
                args.scenario_name
            )
            print(f"✅ Bridge Command scenario created: {output_path}")
        
        else:
            print(f"❌ Error: Unsupported input format: {input_path.suffix}")
            sys.exit(1)
    
    except Exception as e:
        print(f"❌ Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
